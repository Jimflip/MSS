!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
IKAction	Action.cpp	/^IKAction(const std::string& _name,const dart::dynamics::SkeletonPtr& skeleton,$/;"	f	class:MSS::IKAction
KpAction	Action.cpp	/^KpAction(const std::string& _name,const Eigen::VectorXd& upper,const Eigen::VectorXd& lower)$/;"	f	class:MSS::KpAction
MSS	Action.cpp	/^namespace MSS$/;"	n	file:
MotionAction	Action.cpp	/^MotionAction(const std::string& _name,const Eigen::VectorXd& upper,const Eigen::VectorXd& lower)$/;"	f	class:MSS::MotionAction
Set	Action.cpp	/^Set(Eigen::VectorXd& p)$/;"	f	class:MSS::IKAction
SolveIK	Action.cpp	/^SolveIK(const Eigen::VectorXd& p_old,const Eigen::VectorXd& target)$/;"	f	class:MSS::IKAction
GetDof	Action.h	/^	int GetDof(){return target_bn.size()*3;}$/;"	f	class:MSS::IKAction
IKAction	Action.h	/^class IKAction$/;"	c	namespace:MSS
KpAction	Action.h	/^class KpAction$/;"	c	namespace:MSS
MSS	Action.h	/^namespace MSS$/;"	n
MotionAction	Action.h	/^class MotionAction$/;"	c	namespace:MSS
Set	Action.h	/^	void Set(Eigen::VectorXd& p){p+=lb*a;};$/;"	f	class:MSS::KpAction
Set	Action.h	/^	void Set(Eigen::VectorXd& p){p+=lb*a;};$/;"	f	class:MSS::MotionAction
SetLB	Action.h	/^	void SetLB(const Eigen::VectorXd& _lb){lb = _lb;};$/;"	f	class:MSS::IKAction
SetLB	Action.h	/^	void SetLB(double _lb){lb = _lb;};$/;"	f	class:MSS::KpAction
SetLB	Action.h	/^	void SetLB(double _lb){lb = _lb;};$/;"	f	class:MSS::MotionAction
__MSS_MODE_H__	Action.h	2;"	d
a	Action.h	/^	Eigen::VectorXd a;$/;"	m	class:MSS::IKAction
a	Action.h	/^	Eigen::VectorXd a;$/;"	m	class:MSS::KpAction
a	Action.h	/^	Eigen::VectorXd a;$/;"	m	class:MSS::MotionAction
lb	Action.h	/^	Eigen::VectorXd lb;$/;"	m	class:MSS::IKAction
lb	Action.h	/^	double lb;$/;"	m	class:MSS::KpAction
lb	Action.h	/^	double lb;$/;"	m	class:MSS::MotionAction
name	Action.h	/^	std::string name;$/;"	m	class:MSS::IKAction
name	Action.h	/^	std::string name;$/;"	m	class:MSS::KpAction
name	Action.h	/^	std::string name;$/;"	m	class:MSS::MotionAction
num_iteration	Action.h	/^	int num_iteration;$/;"	m	class:MSS::IKAction
skel	Action.h	/^	dart::dynamics::SkeletonPtr skel;$/;"	m	class:MSS::IKAction
target_bn	Action.h	/^	std::vector<dart::dynamics::BodyNode*> target_bn;$/;"	m	class:MSS::IKAction
AddChild	BVH.cpp	/^AddChild(BVHNode* child)$/;"	f	class:MSS::BVHNode
BVH	BVH.cpp	/^BVH()$/;"	f	class:MSS::BVH
BVHNode	BVH.cpp	/^BVHNode(const std::string& name,BVHNode* parent)$/;"	f	class:MSS::BVHNode
CHANNEL_NAME	BVH.cpp	/^std::map<std::string,MSS::BVHNode::CHANNEL> BVHNode::CHANNEL_NAME =$/;"	m	class:MSS::BVHNode	file:
Get	BVH.cpp	/^Get()$/;"	f	class:MSS::BVHNode
Get	BVH.cpp	/^Get(const std::string& bvh_node)$/;"	f	class:MSS::BVH
GetNode	BVH.cpp	/^GetNode(const std::string& name)$/;"	f	class:MSS::BVHNode
GetP0	BVH.cpp	/^GetP0()$/;"	f	class:MSS::BVH
MSS	BVH.cpp	/^namespace MSS$/;"	n	file:
Parse	BVH.cpp	/^Parse(const std::string& file)$/;"	f	class:MSS::BVH
R_x	BVH.cpp	/^R_x(double x)$/;"	f	namespace:MSS
R_y	BVH.cpp	/^Eigen::Matrix3d R_y(double y)$/;"	f	namespace:MSS
R_z	BVH.cpp	/^Eigen::Matrix3d R_z(double z)$/;"	f	namespace:MSS
ReadHierarchy	BVH.cpp	/^ReadHierarchy(BVHNode* parent,const std::string& name,int& channel_offset,std::ifstream& is)$/;"	f	class:MSS::BVH
Set	BVH.cpp	/^Set(const Eigen::Matrix3d& R_t)$/;"	f	class:MSS::BVHNode
Set	BVH.cpp	/^Set(const Eigen::VectorXd& m_t)$/;"	f	class:MSS::BVHNode
SetChannel	BVH.cpp	/^SetChannel(int c_offset,std::vector<std::string>& c_name)$/;"	f	class:MSS::BVHNode
SetMotion	BVH.cpp	/^SetMotion(double t)$/;"	f	class:MSS::BVH
BVH	BVH.h	/^class BVH$/;"	c	namespace:MSS
BVHNode	BVH.h	/^class BVHNode$/;"	c	namespace:MSS
CHANNEL	BVH.h	/^	enum CHANNEL$/;"	g	class:MSS::BVHNode
CHANNEL_NAME	BVH.h	/^	static std::map<std::string,MSS::BVHNode::CHANNEL> CHANNEL_NAME;$/;"	m	class:MSS::BVHNode
GetMaxTime	BVH.h	/^	double GetMaxTime(){return mNumTotalFrames*mTimeStep;}$/;"	f	class:MSS::BVH
GetRootCOM	BVH.h	/^	const Eigen::Vector3d& GetRootCOM(){return mRootCOM;}$/;"	f	class:MSS::BVH
GetTimeStep	BVH.h	/^	double GetTimeStep(){return mTimeStep;}$/;"	f	class:MSS::BVH
MSS	BVH.h	/^namespace MSS$/;"	n
Xpos	BVH.h	/^		Xpos=0,$/;"	e	enum:MSS::BVHNode::CHANNEL
Xrot	BVH.h	/^		Xrot=3,$/;"	e	enum:MSS::BVHNode::CHANNEL
Ypos	BVH.h	/^		Ypos=1,$/;"	e	enum:MSS::BVHNode::CHANNEL
Yrot	BVH.h	/^		Yrot=4,$/;"	e	enum:MSS::BVHNode::CHANNEL
Zpos	BVH.h	/^		Zpos=2,$/;"	e	enum:MSS::BVHNode::CHANNEL
Zrot	BVH.h	/^		Zrot=5$/;"	e	enum:MSS::BVHNode::CHANNEL
__MSS_BVH_H__	BVH.h	2;"	d
mChannel	BVH.h	/^	std::vector<BVHNode::CHANNEL> mChannel;$/;"	m	class:MSS::BVHNode
mChannelOffset	BVH.h	/^	int mChannelOffset;$/;"	m	class:MSS::BVHNode
mChildren	BVH.h	/^	std::vector<BVHNode*> mChildren;$/;"	m	class:MSS::BVHNode
mMap	BVH.h	/^	std::map<std::string,BVHNode*> mMap;$/;"	m	class:MSS::BVH
mMotions	BVH.h	/^	std::vector<Eigen::VectorXd> mMotions;$/;"	m	class:MSS::BVH
mName	BVH.h	/^	std::string mName;$/;"	m	class:MSS::BVHNode
mNumChannels	BVH.h	/^	int mNumChannels;$/;"	m	class:MSS::BVHNode
mNumTotalChannels	BVH.h	/^	int mNumTotalChannels;$/;"	m	class:MSS::BVH
mNumTotalFrames	BVH.h	/^	int mNumTotalFrames;$/;"	m	class:MSS::BVH
mParent	BVH.h	/^	BVHNode* mParent;$/;"	m	class:MSS::BVHNode
mR	BVH.h	/^	Eigen::Matrix3d mR;$/;"	m	class:MSS::BVHNode
mRoot	BVH.h	/^	BVHNode* mRoot;$/;"	m	class:MSS::BVH
mRootCOM	BVH.h	/^	Eigen::Vector3d mRootCOM;$/;"	m	class:MSS::BVH
mRootCOMOffset	BVH.h	/^	Eigen::Vector3d mRootCOMOffset;$/;"	m	class:MSS::BVH
mTimeStep	BVH.h	/^	double mTimeStep;$/;"	m	class:MSS::BVH
Character	Character.cpp	/^Character(const dart::simulation::WorldPtr& world,const std::string& path)$/;"	f	class:MSS::Character
GetIKTargetPositions	Character.cpp	/^GetIKTargetPositions(const Eigen::VectorXd& p,const Eigen::VectorXd& mode_lb)$/;"	f	class:MSS::Character
GetKpKv	Character.cpp	/^GetKpKv(double default_val,const Eigen::VectorXd& mode_lb)$/;"	f	class:MSS::Character
GetSPDAccelerations	Character.cpp	/^GetSPDAccelerations(const Eigen::VectorXd& p_desired, const Eigen::VectorXd& v_desired)$/;"	f	class:MSS::Character
GetSPDForces	Character.cpp	/^GetSPDForces(const Eigen::VectorXd& p_desired, const Eigen::VectorXd& v_desired)$/;"	f	class:MSS::Character
GetTargetPositions	Character.cpp	/^GetTargetPositions(const Eigen::VectorXd& mode_lb)$/;"	f	class:MSS::Character
GetTargetPositionsAndVelocitiesFromBVH	Character.cpp	/^GetTargetPositionsAndVelocitiesFromBVH(const Eigen::VectorXd& mode_lb)$/;"	f	class:MSS::Character
LoadContactPoints	Character.cpp	/^LoadContactPoints(const std::string& path,double threshold,dart::dynamics::BodyNode* ground)$/;"	f	class:MSS::Character
LoadMotionGraph	Character.cpp	/^LoadMotionGraph(const std::string& path,const std::vector<int>& seq,double time_step)$/;"	f	class:MSS::Character
LoadMuscles	Character.cpp	/^LoadMuscles(const std::string& path)$/;"	f	class:MSS::Character
LoadSkeleton	Character.cpp	/^LoadSkeleton(const std::string& path)$/;"	f	class:MSS::Character
MSS	Character.cpp	/^namespace MSS$/;"	n	file:
SetPDParameters	Character.cpp	/^SetPDParameters(const Eigen::VectorXd& kp, const Eigen::VectorXd& kv)$/;"	f	class:MSS::Character
SetPDParameters	Character.cpp	/^SetPDParameters(double kp, double kv)$/;"	f	class:MSS::Character
AddEndEffector	Character.h	/^	void AddEndEffector(const std::string& str){mEndEffectors.push_back(mSkeleton->getBodyNode(str));};$/;"	f	class:MSS::Character
AddInterestBodies	Character.h	/^	void AddInterestBodies(const std::vector<std::string>& str_list){for(int i =0;i<str_list.size();i++) AddInterestBody(str_list[i]);};$/;"	f	class:MSS::Character
AddInterestBody	Character.h	/^	void AddInterestBody(const std::string& str){mInterestBodies.push_back(mSkeleton->getBodyNode(str));};$/;"	f	class:MSS::Character
AddKpAction	Character.h	/^	void AddKpAction(KpAction* mode){mKpActions.push_back(mode);};$/;"	f	class:MSS::Character
AddMotionAction	Character.h	/^	void AddMotionAction(MotionAction* mode){mMotionActions.push_back(mode);};$/;"	f	class:MSS::Character
Character	Character.h	/^class Character$/;"	c	namespace:MSS
GetBVHMap	Character.h	/^	const std::map<std::string,std::string>& GetBVHMap(){return mBVHMap;};$/;"	f	class:MSS::Character
GetContactPoints	Character.h	/^	const std::vector<ContactPoint*>& GetContactPoints() {return mContactPoints;};$/;"	f	class:MSS::Character
GetEndEffectors	Character.h	/^	const std::vector<dart::dynamics::BodyNode*>& GetEndEffectors() {return mEndEffectors;};$/;"	f	class:MSS::Character
GetIKAction	Character.h	/^	IKAction* GetIKAction(){return mIKAction;};$/;"	f	class:MSS::Character
GetInterestBodies	Character.h	/^	const std::vector<dart::dynamics::BodyNode*>& GetInterestBodies() {return mInterestBodies;};$/;"	f	class:MSS::Character
GetKpActions	Character.h	/^	const std::vector<KpAction*>& GetKpActions(){return mKpActions;};$/;"	f	class:MSS::Character
GetMotionActions	Character.h	/^	const std::vector<MotionAction*>& GetMotionActions(){return mMotionActions;};$/;"	f	class:MSS::Character
GetMotionGraph	Character.h	/^	MotionGraph* GetMotionGraph(){return mMotionGraph;};$/;"	f	class:MSS::Character
GetMuscles	Character.h	/^	const std::vector<Muscle*>& GetMuscles() {return mMuscles;};$/;"	f	class:MSS::Character
GetSkeleton	Character.h	/^	const dart::dynamics::SkeletonPtr& GetSkeleton() {return mSkeleton;};$/;"	f	class:MSS::Character
MSS	Character.h	/^namespace MSS$/;"	n
SetIKAction	Character.h	/^	void SetIKAction(IKAction* mode){mIKAction = mode;};$/;"	f	class:MSS::Character
__MSS_CHARACTER_H__	Character.h	2;"	d
mBVHMap	Character.h	/^	std::map<std::string,std::string> mBVHMap;$/;"	m	class:MSS::Character
mContactPoints	Character.h	/^	std::vector<ContactPoint*> mContactPoints;$/;"	m	class:MSS::Character
mEndEffectors	Character.h	/^	std::vector<dart::dynamics::BodyNode*> mEndEffectors;$/;"	m	class:MSS::Character
mIKAction	Character.h	/^	IKAction* mIKAction;$/;"	m	class:MSS::Character
mInterestBodies	Character.h	/^	std::vector<dart::dynamics::BodyNode*> mInterestBodies;$/;"	m	class:MSS::Character
mKp	Character.h	/^	Eigen::VectorXd mKp, mKv;$/;"	m	class:MSS::Character
mKpActions	Character.h	/^	std::vector<KpAction*> mKpActions;$/;"	m	class:MSS::Character
mKv	Character.h	/^	Eigen::VectorXd mKp, mKv;$/;"	m	class:MSS::Character
mMotionActions	Character.h	/^	std::vector<MotionAction*> mMotionActions;$/;"	m	class:MSS::Character
mMotionGraph	Character.h	/^	MotionGraph* mMotionGraph;$/;"	m	class:MSS::Character
mMuscles	Character.h	/^	std::vector<Muscle*> mMuscles;$/;"	m	class:MSS::Character
mSkeleton	Character.h	/^	dart::dynamics::SkeletonPtr mSkeleton;$/;"	m	class:MSS::Character
mWorld	Character.h	/^	dart::simulation::WorldPtr mWorld;$/;"	m	class:MSS::Character
Add	ContactPoint.cpp	/^Add(const dart::simulation::WorldPtr& world)$/;"	f	class:MSS::ContactPoint
AddNeighbor	ContactPoint.cpp	/^AddNeighbor(ContactPoint* other)$/;"	f	class:MSS::ContactPoint
CheckColliding	ContactPoint.cpp	/^CheckColliding()$/;"	f	class:MSS::ContactPoint
ContactPoint	ContactPoint.cpp	/^ContactPoint(const dart::simulation::WorldPtr& world, dart::dynamics::BodyNode* bn,dart::dynamics::BodyNode* grd,const Eigen::Vector3d& v)$/;"	f	class:MSS::ContactPoint
GetPosition	ContactPoint.cpp	/^GetPosition()$/;"	f	class:MSS::ContactPoint
MSS	ContactPoint.cpp	/^namespace MSS$/;"	n	file:
Remove	ContactPoint.cpp	/^Remove(const dart::simulation::WorldPtr& world)$/;"	f	class:MSS::ContactPoint
ContactPoint	ContactPoint.h	/^class ContactPoint$/;"	c	namespace:MSS
ContactPointCollisionObject	ContactPoint.h	/^	ContactPointCollisionObject(const dart::simulation::WorldPtr& world,dart::dynamics::BodyNode* bn):CollisionObject(world->getConstraintSolver()->getCollisionDetector().get(),dynamic_cast<dart::dynamics::ShapeFrame*>(bn->getShapeNodesWith<dart::dynamics::VisualAspect>()[0])){};$/;"	f	class:MSS::ContactPointCollisionObject
ContactPointCollisionObject	ContactPoint.h	/^class ContactPointCollisionObject: public dart::collision::CollisionObject$/;"	c	namespace:MSS
GetNeighbor	ContactPoint.h	/^	const std::vector<ContactPoint*>& GetNeighbor(){return neighbor;};$/;"	f	class:MSS::ContactPoint
IsColliding	ContactPoint.h	/^	bool IsColliding(){return is_colliding;}$/;"	f	class:MSS::ContactPoint
IsContactOn	ContactPoint.h	/^	bool IsContactOn(){return is_contact_on;}$/;"	f	class:MSS::ContactPoint
MSS	ContactPoint.h	/^namespace MSS$/;"	n
__MSS_CONTACT_POINT_H__	ContactPoint.h	2;"	d
contact	ContactPoint.h	/^	dart::collision::Contact contact;$/;"	m	class:MSS::ContactPoint
contact_body	ContactPoint.h	/^	dart::dynamics::BodyNode* contact_body;$/;"	m	class:MSS::ContactPoint
contact_constraint	ContactPoint.h	/^	dart::constraint::ContactConstraintPtr	contact_constraint;$/;"	m	class:MSS::ContactPoint
ground	ContactPoint.h	/^	dart::dynamics::BodyNode* ground;$/;"	m	class:MSS::ContactPoint
ground_y	ContactPoint.h	/^	double ground_y;$/;"	m	class:MSS::ContactPoint
is_colliding	ContactPoint.h	/^	bool is_colliding;$/;"	m	class:MSS::ContactPoint
is_contact_on	ContactPoint.h	/^	bool is_contact_on;$/;"	m	class:MSS::ContactPoint
local_position	ContactPoint.h	/^	Eigen::Vector3d local_position;$/;"	m	class:MSS::ContactPoint
neighbor	ContactPoint.h	/^	std::vector<ContactPoint*> neighbor;$/;"	m	class:MSS::ContactPoint
updateEngineData	ContactPoint.h	/^	virtual void updateEngineData(){};$/;"	f	class:MSS::ContactPointCollisionObject
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
ComputeActivationQP	Environment.cpp	/^ComputeActivationQP()$/;"	f	class:MSS::Environment
Environment	Environment.cpp	/^Environment(int control_Hz,int simulation_Hz)$/;"	f	class:MSS::Environment
GetDesiredTorques	Environment.cpp	/^GetDesiredTorques()$/;"	f	class:MSS::Environment
GetMuscleTorques	Environment.cpp	/^GetMuscleTorques()$/;"	f	class:MSS::Environment
GetReward	Environment.cpp	/^GetReward()$/;"	f	class:MSS::Environment
GetState	Environment.cpp	/^GetState()$/;"	f	class:MSS::Environment
IsTerminalState	Environment.cpp	/^IsTerminalState()$/;"	f	class:MSS::Environment
MSS	Environment.cpp	/^namespace MSS$/;"	n	file:
Reset	Environment.cpp	/^Reset(bool random)$/;"	f	class:MSS::Environment
SetAction	Environment.cpp	/^SetAction(const Eigen::VectorXd& a)$/;"	f	class:MSS::Environment
Step	Environment.cpp	/^Step(const Eigen::VectorXd& activation)$/;"	f	class:MSS::Environment
exp_of_squared	Environment.cpp	/^double exp_of_squared(const Eigen::Vector3d& vec,double w = 1.0)$/;"	f	namespace:MSS
exp_of_squared	Environment.cpp	/^double exp_of_squared(const Eigen::VectorXd& vec,double w = 1.0)$/;"	f	namespace:MSS
exp_of_squared	Environment.cpp	/^double exp_of_squared(double val,double w = 1.0)$/;"	f	namespace:MSS
A	Environment.h	/^	Eigen::MatrixXd A;$/;"	m	struct:MSS::Tuple
Environment	Environment.h	/^class Environment$/;"	c	namespace:MSS
GetAction	Environment.h	/^	Eigen::VectorXd GetAction(){return mAction;}$/;"	f	class:MSS::Environment
GetCharacter	Environment.h	/^	Character* GetCharacter(){return mCharacter;};$/;"	f	class:MSS::Environment
GetControlHz	Environment.h	/^	int GetControlHz(){return mControlHz;};$/;"	f	class:MSS::Environment
GetElapsedTime	Environment.h	/^	double GetElapsedTime(){return mTimeElapsed;}$/;"	f	class:MSS::Environment
GetGround	Environment.h	/^	const dart::dynamics::SkeletonPtr& GetGround(){return mGround;}	$/;"	f	class:MSS::Environment
GetNumAction	Environment.h	/^	int GetNumAction(){return mAction.rows();};$/;"	f	class:MSS::Environment
GetNumState	Environment.h	/^	int GetNumState(){return GetState().rows();};$/;"	f	class:MSS::Environment
GetNumTotalRelatedDofs	Environment.h	/^	int GetNumTotalRelatedDofs(){return mNumTotalRelatedDofs;};$/;"	f	class:MSS::Environment
GetQP	Environment.h	/^	QP*	GetQP(){return mQP;}$/;"	f	class:MSS::Environment
GetSimulationHz	Environment.h	/^	int GetSimulationHz(){return mSimulationHz;};$/;"	f	class:MSS::Environment
GetTuples	Environment.h	/^	std::vector<Tuple>& GetTuples(){return mTuples;};$/;"	f	class:MSS::Environment
GetWorld	Environment.h	/^	const dart::simulation::WorldPtr& GetWorld(){return mWorld;};$/;"	f	class:MSS::Environment
MSS	Environment.h	/^namespace MSS$/;"	n
Tuple	Environment.h	/^struct Tuple$/;"	s	namespace:MSS
__MSS_ENVIRONMENT_H__	Environment.h	2;"	d
b	Environment.h	/^	Eigen::VectorXd b;$/;"	m	struct:MSS::Tuple
mAction	Environment.h	/^	Eigen::VectorXd mAction;$/;"	m	class:MSS::Environment
mCharacter	Environment.h	/^	Character* mCharacter;$/;"	m	class:MSS::Environment
mControlHz	Environment.h	/^	int mControlHz;$/;"	m	class:MSS::Environment
mGround	Environment.h	/^	dart::dynamics::SkeletonPtr mGround;$/;"	m	class:MSS::Environment
mNumTotalRelatedDofs	Environment.h	/^	int mNumTotalRelatedDofs;$/;"	m	class:MSS::Environment
mQP	Environment.h	/^	QP*	mQP;$/;"	m	class:MSS::Environment
mSimulationHz	Environment.h	/^	int mSimulationHz;$/;"	m	class:MSS::Environment
mTarget	Environment.h	/^	std::pair<Eigen::VectorXd,Eigen::VectorXd> mTarget;$/;"	m	class:MSS::Environment
mTimeElapsed	Environment.h	/^	double mTimeElapsed;$/;"	m	class:MSS::Environment
mTorqueDesired	Environment.h	/^	Eigen::VectorXd mTorqueDesired;$/;"	m	class:MSS::Environment
mTuples	Environment.h	/^	std::vector<Tuple> mTuples;$/;"	m	class:MSS::Environment
mWorld	Environment.h	/^	dart::simulation::WorldPtr mWorld;$/;"	m	class:MSS::Environment
tau	Environment.h	/^	Eigen::VectorXd tau;$/;"	m	struct:MSS::Tuple
tau_des	Environment.h	/^	Eigen::VectorXd tau_des;$/;"	m	struct:MSS::Tuple
w_com	Environment.h	/^	double w_p,w_v,w_ee,w_com;$/;"	m	class:MSS::Environment
w_ee	Environment.h	/^	double w_p,w_v,w_ee,w_com;$/;"	m	class:MSS::Environment
w_p	Environment.h	/^	double w_p,w_v,w_ee,w_com;$/;"	m	class:MSS::Environment
w_v	Environment.h	/^	double w_p,w_v,w_ee,w_com;$/;"	m	class:MSS::Environment
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
MSS	Functions.cpp	/^namespace MSS$/;"	n	file:
split_to_double	Functions.cpp	/^std::vector<double> split_to_double(const std::string& input, int num)$/;"	f	namespace:MSS
string_to_matrix3d	Functions.cpp	/^Eigen::Matrix3d string_to_matrix3d(const std::string& input){$/;"	f	namespace:MSS
string_to_vector3d	Functions.cpp	/^Eigen::Vector3d string_to_vector3d(const std::string& input){$/;"	f	namespace:MSS
string_to_vectorXd	Functions.cpp	/^Eigen::VectorXd string_to_vectorXd(const std::string& input, int n){$/;"	f	namespace:MSS
MSS	Functions.h	/^namespace MSS$/;"	n
__MSS_FUNCTIONS_H__	Functions.h	2;"	d
AddDisplacementVector	MotionGraph.cpp	/^AddDisplacementVector(const Eigen::VectorXd& m_t, const Eigen::VectorXd& d)$/;"	f	class:MSS::MotionGraph
ComputeDisplacementVector	MotionGraph.cpp	/^ComputeDisplacementVector(int i,int j)$/;"	f	class:MSS::MotionGraph
ComputeMotionVector	MotionGraph.cpp	/^ComputeMotionVector(int i,double t)$/;"	f	class:MSS::MotionGraph
GetMotion	MotionGraph.cpp	/^GetMotion()$/;"	f	class:MSS::MotionGraph
LoadState	MotionGraph.cpp	/^LoadState()$/;"	f	class:MSS::MotionGraph
MSS	MotionGraph.cpp	/^namespace MSS$/;"	n	file:
MotionGraph	MotionGraph.cpp	/^MotionGraph(const dart::dynamics::SkeletonPtr& skel,std::map<std::string,std::string> bvh_map,double time_step)$/;"	f	class:MSS::MotionGraph
Parse	MotionGraph.cpp	/^Parse(const std::string& path)$/;"	f	class:MSS::MotionGraph
Reset	MotionGraph.cpp	/^Reset(double t)$/;"	f	class:MSS::MotionGraph
SaveState	MotionGraph.cpp	/^SaveState()$/;"	f	class:MSS::MotionGraph
SetWalk	MotionGraph.cpp	/^SetWalk(const std::vector<int>& sequences)$/;"	f	class:MSS::MotionGraph
Step	MotionGraph.cpp	/^Step()$/;"	f	class:MSS::MotionGraph
GetMaxTime	MotionGraph.h	/^	double GetMaxTime() {return mMaxTime;};$/;"	f	class:MSS::MotionGraph
GetMaxTimeOfFirstSeq	MotionGraph.h	/^	double GetMaxTimeOfFirstSeq() {return mBVHs[mSequences[0]]->GetMaxTime();};$/;"	f	class:MSS::MotionGraph
GetPhase	MotionGraph.h	/^	double GetPhase() {return mElapsedTime\/mBVHs[mSequences[mCurrentSequence]]->GetMaxTime();}$/;"	f	class:MSS::MotionGraph
GetTimeStep	MotionGraph.h	/^	double GetTimeStep(){return mTimeStep;}$/;"	f	class:MSS::MotionGraph
MSS	MotionGraph.h	/^namespace MSS$/;"	n
MotionGraph	MotionGraph.h	/^class MotionGraph$/;"	c	namespace:MSS
ScaleFunc	MotionGraph.h	/^	static double ScaleFunc(double t){if(t<1.0) return (t-1.0)*(2.0*t*t-t-1); else return 0.0;}$/;"	f	class:MSS::MotionGraph
__MSS_MOTION_GRAPH_H__	MotionGraph.h	2;"	d
mBVHMap	MotionGraph.h	/^	std::map<std::string,std::string> mBVHMap;$/;"	m	class:MSS::MotionGraph
mBVHs	MotionGraph.h	/^	std::vector<BVH*> mBVHs;$/;"	m	class:MSS::MotionGraph
mCurrentRootOffset	MotionGraph.h	/^	Eigen::Vector6d mCurrentRootOffset;$/;"	m	class:MSS::MotionGraph
mCurrentSequence	MotionGraph.h	/^	int mCurrentSequence;$/;"	m	class:MSS::MotionGraph
mElapsedTime	MotionGraph.h	/^	double mElapsedTime;$/;"	m	class:MSS::MotionGraph
mMaxTime	MotionGraph.h	/^	double mMaxTime;$/;"	m	class:MSS::MotionGraph
mRtarget	MotionGraph.h	/^	Eigen::Matrix3d mRtarget,mRy;$/;"	m	class:MSS::MotionGraph
mRy	MotionGraph.h	/^	Eigen::Matrix3d mRtarget,mRy;$/;"	m	class:MSS::MotionGraph
mSaveCurrentRootOffset	MotionGraph.h	/^	Eigen::Vector6d mSaveCurrentRootOffset;$/;"	m	class:MSS::MotionGraph
mSaveCurrentSequence	MotionGraph.h	/^	int mSaveCurrentSequence;$/;"	m	class:MSS::MotionGraph
mSaveElapsedTime	MotionGraph.h	/^	double mSaveElapsedTime;$/;"	m	class:MSS::MotionGraph
mSaveRtarget	MotionGraph.h	/^	Eigen::Matrix3d mSaveRtarget;$/;"	m	class:MSS::MotionGraph
mSaveRy	MotionGraph.h	/^	Eigen::Matrix3d mSaveRy;$/;"	m	class:MSS::MotionGraph
mSaveTotalElapsedTime	MotionGraph.h	/^	double mSaveTotalElapsedTime;$/;"	m	class:MSS::MotionGraph
mSaved	MotionGraph.h	/^	Eigen::VectorXd mSaved;$/;"	m	class:MSS::MotionGraph
mSequences	MotionGraph.h	/^	std::vector<int> mSequences;$/;"	m	class:MSS::MotionGraph
mSkeleton	MotionGraph.h	/^	dart::dynamics::SkeletonPtr mSkeleton;$/;"	m	class:MSS::MotionGraph
mTimeStep	MotionGraph.h	/^	double mTimeStep;$/;"	m	class:MSS::MotionGraph
mTotalElapsedTime	MotionGraph.h	/^	double mTotalElapsedTime;$/;"	m	class:MSS::MotionGraph
mTransitions	MotionGraph.h	/^	std::vector<std::vector<int>> mTransitions;$/;"	m	class:MSS::MotionGraph
md	MotionGraph.h	/^	Eigen::VectorXd md;$/;"	m	class:MSS::MotionGraph
mt_s	MotionGraph.h	/^	double mt_s;$/;"	m	class:MSS::MotionGraph
AddAnchor	Muscle.cpp	/^AddAnchor(dart::dynamics::BodyNode* bn,const Eigen::Vector3d& glob_pos)$/;"	f	class:MSS::Muscle
ApplyForceToBody	Muscle.cpp	/^ApplyForceToBody()$/;"	f	class:MSS::Muscle
GetForce	Muscle.cpp	/^GetForce()$/;"	f	class:MSS::Muscle
GetForceJacobianAndPassive	Muscle.cpp	/^GetForceJacobianAndPassive()$/;"	f	class:MSS::Muscle
GetJacobianTranspose	Muscle.cpp	/^GetJacobianTranspose()$/;"	f	class:MSS::Muscle
GetPoint	Muscle.cpp	/^Eigen::Vector3d GetPoint(const std::pair<dart::dynamics::BodyNode*,Eigen::Vector3d>& bnpos)$/;"	f	namespace:MSS
GetPoint	Muscle.cpp	/^Eigen::Vector3d GetPoint(dart::dynamics::BodyNode* bn,const Eigen::Vector3d& local_pos)$/;"	f	namespace:MSS
GetRelatedJtA	Muscle.cpp	/^GetRelatedJtA()$/;"	f	class:MSS::Muscle
Getf_A	Muscle.cpp	/^Getf_A()$/;"	f	class:MSS::Muscle
Getf_p	Muscle.cpp	/^Getf_p()$/;"	f	class:MSS::Muscle
Getl_mt	Muscle.cpp	/^Getl_mt()$/;"	f	class:MSS::Muscle
MSS	Muscle.cpp	/^namespace MSS$/;"	n	file:
Muscle	Muscle.cpp	/^Muscle(std::string _name,double _f0,double _lm0,double _lt0,double _pen_angle)$/;"	f	class:MSS::Muscle
Update	Muscle.cpp	/^Update(double time_step)$/;"	f	class:MSS::Muscle
GetAnchors	Muscle.h	/^	const std::vector<std::pair<dart::dynamics::BodyNode*,Eigen::Vector3d>>& GetAnchors(){return mAnchors;}$/;"	f	class:MSS::Muscle
GetNumRelatedDofs	Muscle.h	/^	int GetNumRelatedDofs(){return num_related_dofs;};$/;"	f	class:MSS::Muscle
MSS	Muscle.h	/^namespace MSS$/;"	n
Muscle	Muscle.h	/^class Muscle$/;"	c	namespace:MSS
__MSS_MUSCLE_H__	Muscle.h	2;"	d
activation	Muscle.h	/^	double activation;$/;"	m	class:MSS::Muscle
f0	Muscle.h	/^	double f0;$/;"	m	class:MSS::Muscle
l_mt	Muscle.h	/^	double l_mt;$/;"	m	class:MSS::Muscle
l_mt0	Muscle.h	/^	double l_mt0;$/;"	m	class:MSS::Muscle
mAnchors	Muscle.h	/^	std::vector<std::pair<dart::dynamics::BodyNode*,Eigen::Vector3d>> mAnchors;$/;"	m	class:MSS::Muscle
name	Muscle.h	/^	std::string name;$/;"	m	class:MSS::Muscle
num_related_dofs	Muscle.h	/^	int num_related_dofs;$/;"	m	class:MSS::Muscle
related_dof_indices	Muscle.h	/^	std::vector<int> related_dof_indices;$/;"	m	class:MSS::Muscle
GetJtA	QP.cpp	/^GetJtA()$/;"	f	class:QP
GetJtP	QP.cpp	/^GetJtP()$/;"	f	class:QP
GetJtp_minus_c	QP.cpp	/^GetJtp_minus_c()$/;"	f	class:QP
Initialize	QP.cpp	/^Initialize()$/;"	f	class:QP
Minimize	QP.cpp	/^Minimize(const Eigen::VectorXd& qdd_desired)$/;"	f	class:QP
QP	QP.cpp	/^QP(MSS::Character* character)$/;"	f	class:QP
Update	QP.cpp	/^Update(const Eigen::VectorXd& qdd_desired)$/;"	f	class:QP
print_matrix	QP.cpp	/^void print_matrix(const char* name, const quadprogpp::Matrix<double>& A, int n=-1, int m=-1)$/;"	f
print_vector	QP.cpp	/^void print_vector(const char* name, const quadprogpp::Vector<double>& v, int n=-1)$/;"	f
A	QP.h	/^	quadprogpp::Matrix<double> A;$/;"	m	class:MSS::QP
D	QP.h	/^	quadprogpp::Matrix<double> D;$/;"	m	class:MSS::QP
GetSolution	QP.h	/^	Eigen::VectorXd GetSolution(){return mSolution;}$/;"	f	class:MSS::QP
H	QP.h	/^	quadprogpp::Matrix<double> H;$/;"	m	class:MSS::QP
MSS	QP.h	/^namespace MSS$/;"	n
QP	QP.h	/^class QP$/;"	c	namespace:MSS
__QP_H__	QP.h	2;"	d
b	QP.h	/^	quadprogpp::Vector<double> b;$/;"	m	class:MSS::QP
c	QP.h	/^	quadprogpp::Vector<double> c;$/;"	m	class:MSS::QP
e	QP.h	/^	quadprogpp::Vector<double> e;$/;"	m	class:MSS::QP
mA	QP.h	/^	std::vector<Eigen::MatrixXd> mJt,mA;$/;"	m	class:MSS::QP
mCharacter	QP.h	/^	MSS::Character* mCharacter;$/;"	m	class:MSS::QP
mJt	QP.h	/^	std::vector<Eigen::MatrixXd> mJt,mA;$/;"	m	class:MSS::QP
mJtA	QP.h	/^	Eigen::MatrixXd mJtA;$/;"	m	class:MSS::QP
mJtp	QP.h	/^	Eigen::VectorXd mJtp;$/;"	m	class:MSS::QP
mJtp_minus_c	QP.h	/^	Eigen::VectorXd mJtp_minus_c;$/;"	m	class:MSS::QP
mM_minus_JtA	QP.h	/^	Eigen::MatrixXd mM_minus_JtA;$/;"	m	class:MSS::QP
mNumDofs	QP.h	/^	int mNumDofs,mNumMuscles;$/;"	m	class:MSS::QP
mNumMuscles	QP.h	/^	int mNumDofs,mNumMuscles;$/;"	m	class:MSS::QP
mP	QP.h	/^	std::vector<Eigen::VectorXd> mP;$/;"	m	class:MSS::QP
mQddDesired	QP.h	/^	Eigen::VectorXd mQddDesired;$/;"	m	class:MSS::QP
mSolution	QP.h	/^	Eigen::VectorXd mSolution;$/;"	m	class:MSS::QP
mW_effort	QP.h	/^	double mW_effort,mW_tracking;$/;"	m	class:MSS::QP
mW_tracking	QP.h	/^	double mW_effort,mW_tracking;$/;"	m	class:MSS::QP
x	QP.h	/^	quadprogpp::Vector<double> x;$/;"	m	class:MSS::QP
BuildFromFile	SkeletonBuilder.cpp	/^BuildFromFile(const std::string& filename){$/;"	f	class:MSS::SkeletonBuilder
MSS	SkeletonBuilder.cpp	/^namespace MSS$/;"	n	file:
MakeBallJointBody	SkeletonBuilder.cpp	/^BodyNode* SkeletonBuilder::MakeBallJointBody($/;"	f	class:MSS::SkeletonBuilder
MakeFreeJointBody	SkeletonBuilder.cpp	/^BodyNode* SkeletonBuilder::MakeFreeJointBody($/;"	f	class:MSS::SkeletonBuilder
MakePrismaticJointBody	SkeletonBuilder.cpp	/^BodyNode* SkeletonBuilder::MakePrismaticJointBody($/;"	f	class:MSS::SkeletonBuilder
MakeRevoluteJointBody	SkeletonBuilder.cpp	/^BodyNode* SkeletonBuilder::MakeRevoluteJointBody($/;"	f	class:MSS::SkeletonBuilder
MakeWeldJointBody	SkeletonBuilder.cpp	/^BodyNode* SkeletonBuilder::MakeWeldJointBody($/;"	f	class:MSS::SkeletonBuilder
Orthonormalize	SkeletonBuilder.cpp	/^Eigen::Isometry3d Orthonormalize(const Eigen::Isometry3d& T_old)$/;"	f	namespace:MSS
Proj	SkeletonBuilder.cpp	/^Eigen::Vector3d Proj(const Eigen::Vector3d& u,const Eigen::Vector3d& v)$/;"	f	namespace:MSS
MSS	SkeletonBuilder.h	/^namespace MSS$/;"	n
SkeletonBuilder	SkeletonBuilder.h	/^class SkeletonBuilder$/;"	c	namespace:MSS
__MSS_SKELETON_BUILDER_H__	SkeletonBuilder.h	2;"	d
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
quadprogpp	quadprog_optimized/Array.cc	/^namespace quadprogpp {$/;"	n	file:
seq	quadprog_optimized/Array.cc	/^std::set<unsigned int> seq(unsigned int s, unsigned int e)$/;"	f	namespace:quadprogpp
singleton	quadprog_optimized/Array.cc	/^std::set<unsigned int> singleton(unsigned int i)$/;"	f	namespace:quadprogpp
CanonicalBaseVector	quadprog_optimized/Array.hh	/^CanonicalBaseVector<T>::CanonicalBaseVector(unsigned int i, unsigned int n)$/;"	f	class:quadprogpp::CanonicalBaseVector
CanonicalBaseVector	quadprog_optimized/Array.hh	/^class CanonicalBaseVector : public Vector<T>$/;"	c	namespace:quadprogpp
DIAG	quadprog_optimized/Array.hh	/^enum MType { DIAG };$/;"	e	enum:quadprogpp::MType
MType	quadprog_optimized/Array.hh	/^enum MType { DIAG };$/;"	g	namespace:quadprogpp
Matrix	quadprog_optimized/Array.hh	/^Matrix<T>::Matrix() $/;"	f	class:quadprogpp::Matrix
Matrix	quadprog_optimized/Array.hh	/^Matrix<T>::Matrix(MType t, const T& a, const T& o, unsigned int n, unsigned int m) $/;"	f	class:quadprogpp::Matrix
Matrix	quadprog_optimized/Array.hh	/^Matrix<T>::Matrix(MType t, const Vector<T>& a, const T& o, unsigned int n, unsigned int m) $/;"	f	class:quadprogpp::Matrix
Matrix	quadprog_optimized/Array.hh	/^Matrix<T>::Matrix(const Matrix<T>& rhs)$/;"	f	class:quadprogpp::Matrix
Matrix	quadprog_optimized/Array.hh	/^Matrix<T>::Matrix(const T& a, unsigned int n, unsigned int m)$/;"	f	class:quadprogpp::Matrix
Matrix	quadprog_optimized/Array.hh	/^Matrix<T>::Matrix(const T* a, unsigned int n, unsigned int m) $/;"	f	class:quadprogpp::Matrix
Matrix	quadprog_optimized/Array.hh	/^Matrix<T>::Matrix(unsigned int n, unsigned int m)$/;"	f	class:quadprogpp::Matrix
Matrix	quadprog_optimized/Array.hh	/^class Matrix $/;"	c	namespace:quadprogpp
Vector	quadprog_optimized/Array.hh	/^Vector<T>::Vector() $/;"	f	class:quadprogpp::Vector
Vector	quadprog_optimized/Array.hh	/^Vector<T>::Vector(const T& a, const unsigned int n) $/;"	f	class:quadprogpp::Vector
Vector	quadprog_optimized/Array.hh	/^Vector<T>::Vector(const T* a, const unsigned int n) $/;"	f	class:quadprogpp::Vector
Vector	quadprog_optimized/Array.hh	/^Vector<T>::Vector(const Vector<T>& rhs) $/;"	f	class:quadprogpp::Vector
Vector	quadprog_optimized/Array.hh	/^Vector<T>::Vector(const unsigned int n) $/;"	f	class:quadprogpp::Vector
Vector	quadprog_optimized/Array.hh	/^class Vector$/;"	c	namespace:quadprogpp
_ARRAY_HH	quadprog_optimized/Array.hh	10;"	d
abs	quadprog_optimized/Array.hh	/^inline Vector<T> abs(const Vector<T>& v)$/;"	f	namespace:quadprogpp
all_mean	quadprog_optimized/Array.hh	/^T all_mean(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
all_prod	quadprog_optimized/Array.hh	/^T all_prod(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
all_sum	quadprog_optimized/Array.hh	/^T all_sum(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
backward_elimination	quadprog_optimized/Array.hh	/^Vector<T> backward_elimination(const Matrix<T>& U, const Vector<T> y)$/;"	f	namespace:quadprogpp
backward_elimination	quadprog_optimized/Array.hh	/^void backward_elimination(const Matrix<T>& U, Vector<T>& x, const Vector<T>& y)$/;"	f	namespace:quadprogpp
cholesky	quadprog_optimized/Array.hh	/^Matrix<T> cholesky(const Matrix<T> A) $/;"	f	namespace:quadprogpp
cholesky	quadprog_optimized/Array.hh	/^void cholesky(const Matrix<T> A, Matrix<T>& LL) $/;"	f	namespace:quadprogpp
cholesky_solve	quadprog_optimized/Array.hh	/^Vector<T> cholesky_solve(const Matrix<T>& LL, const Vector<T>& b)$/;"	f	namespace:quadprogpp
cholesky_solve	quadprog_optimized/Array.hh	/^void cholesky_solve(const Matrix<T>& LL, Vector<T>& x, const Vector<T>& b)$/;"	f	namespace:quadprogpp
det	quadprog_optimized/Array.hh	2178;"	d
dist	quadprog_optimized/Array.hh	/^T dist(const T& a, const T& b)$/;"	f	namespace:quadprogpp
dot_prod	quadprog_optimized/Array.hh	/^Matrix<T> dot_prod(const Matrix<T>& a, const Matrix<T>& b)$/;"	f	namespace:quadprogpp
dot_prod	quadprog_optimized/Array.hh	/^Matrix<T> dot_prod(const Matrix<T>& a, const Vector<T>& b)$/;"	f	namespace:quadprogpp
dot_prod	quadprog_optimized/Array.hh	/^Matrix<T> dot_prod(const Vector<T>& a, const Matrix<T>& b)$/;"	f	namespace:quadprogpp
dot_prod	quadprog_optimized/Array.hh	/^inline T dot_prod(const Vector<T>& a, const Vector<T>& b)$/;"	f	namespace:quadprogpp
e	quadprog_optimized/Array.hh	/^  unsigned int e;$/;"	m	class:quadprogpp::CanonicalBaseVector
exp	quadprog_optimized/Array.hh	/^Matrix<T> exp(const Matrix<T>&m)$/;"	f	namespace:quadprogpp
exp	quadprog_optimized/Array.hh	/^inline Vector<T> exp(const Vector<T>& v)$/;"	f	namespace:quadprogpp
extract	quadprog_optimized/Array.hh	/^inline Matrix<T> Matrix<T>::extract(const std::set<unsigned int>& r_indexes, const std::set<unsigned int>& c_indexes) const$/;"	f	class:quadprogpp::Matrix
extract	quadprog_optimized/Array.hh	/^inline Vector<T> Vector<T>::extract(const std::set<unsigned int>& indexes) const$/;"	f	class:quadprogpp::Vector
extractColumn	quadprog_optimized/Array.hh	/^inline Vector<T> Matrix<T>::extractColumn(const unsigned int j) const$/;"	f	class:quadprogpp::Matrix
extractColumns	quadprog_optimized/Array.hh	/^inline Matrix<T> Matrix<T>::extractColumns(const std::set<unsigned int>& indexes) const$/;"	f	class:quadprogpp::Matrix
extractDiag	quadprog_optimized/Array.hh	/^inline Vector<T> Matrix<T>::extractDiag() const$/;"	f	class:quadprogpp::Matrix
extractRow	quadprog_optimized/Array.hh	/^inline Vector<T> Matrix<T>::extractRow(const unsigned int i) const$/;"	f	class:quadprogpp::Matrix
extractRows	quadprog_optimized/Array.hh	/^inline Matrix<T> Matrix<T>::extractRows(const std::set<unsigned int>& indexes) const$/;"	f	class:quadprogpp::Matrix
forward_elimination	quadprog_optimized/Array.hh	/^Vector<T> forward_elimination(const Matrix<T>& L, const Vector<T> b)$/;"	f	namespace:quadprogpp
forward_elimination	quadprog_optimized/Array.hh	/^void forward_elimination(const Matrix<T>& L, Vector<T>& y, const Vector<T> b)$/;"	f	namespace:quadprogpp
index_max	quadprog_optimized/Array.hh	/^inline unsigned int index_max(const Vector<T>& v)$/;"	f	namespace:quadprogpp
index_min	quadprog_optimized/Array.hh	/^inline unsigned int index_min(const Vector<T>& v)$/;"	f	namespace:quadprogpp
inverse	quadprog_optimized/Array.hh	2179;"	d
kron	quadprog_optimized/Array.hh	/^Matrix<T> kron(const Vector<T>& b, const Vector<T>& a)$/;"	f	namespace:quadprogpp
log	quadprog_optimized/Array.hh	/^inline Vector<T> log(const Vector<T>& v)$/;"	f	namespace:quadprogpp
lu	quadprog_optimized/Array.hh	/^int lu(const Matrix<T>& A, Matrix<T>& LU, Vector<unsigned int>& index)$/;"	f	namespace:quadprogpp
lu_det	quadprog_optimized/Array.hh	/^T lu_det(const Matrix<T>& A)$/;"	f	namespace:quadprogpp
lu_inverse	quadprog_optimized/Array.hh	/^Matrix<T> lu_inverse(const Matrix<T>& A)$/;"	f	namespace:quadprogpp
lu_solve	quadprog_optimized/Array.hh	/^Vector<T> lu_solve(const Matrix<T>& LU, const Vector<T>& b, Vector<unsigned int>& index)$/;"	f	namespace:quadprogpp
lu_solve	quadprog_optimized/Array.hh	/^void lu_solve(const Matrix<T>& LU, Vector<T>& x, const Vector<T>& b, Vector<unsigned int>& index)$/;"	f	namespace:quadprogpp
m	quadprog_optimized/Array.hh	/^  unsigned int m; \/\/ number of columns$/;"	m	class:quadprogpp::Matrix
mat_sqrt	quadprog_optimized/Array.hh	/^Matrix<T> mat_sqrt(const Matrix<T>&m)$/;"	f	namespace:quadprogpp
max	quadprog_optimized/Array.hh	/^Vector<T> max(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
max	quadprog_optimized/Array.hh	/^inline T max(const Vector<T>& v)$/;"	f	namespace:quadprogpp
mean	quadprog_optimized/Array.hh	/^Vector<T> mean(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
mean	quadprog_optimized/Array.hh	/^inline T mean(const Vector<T>& v)$/;"	f	namespace:quadprogpp
median	quadprog_optimized/Array.hh	/^inline T median(const Vector<T>& v)$/;"	f	namespace:quadprogpp
min	quadprog_optimized/Array.hh	/^Vector<T> min(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
min	quadprog_optimized/Array.hh	/^inline T min(const Vector<T>& v)$/;"	f	namespace:quadprogpp
n	quadprog_optimized/Array.hh	/^  unsigned int n; \/\/ number of rows$/;"	m	class:quadprogpp::Matrix
n	quadprog_optimized/Array.hh	/^  unsigned int n; \/\/ size of array. upper index is n-1 $/;"	m	class:quadprogpp::Vector
ncols	quadprog_optimized/Array.hh	/^  inline unsigned int ncols() const { return m; } \/\/ number of columns$/;"	f	class:quadprogpp::Matrix
nrows	quadprog_optimized/Array.hh	/^  inline unsigned int nrows() const { return n; } \/\/ number of rows$/;"	f	class:quadprogpp::Matrix
operator !=	quadprog_optimized/Array.hh	/^inline bool operator!=(const Matrix<T>& a, const Matrix<T>& b)$/;"	f	namespace:quadprogpp
operator !=	quadprog_optimized/Array.hh	/^inline bool operator!=(const Vector<T>& v, const Vector<T>& w)$/;"	f	namespace:quadprogpp
operator *	quadprog_optimized/Array.hh	/^Matrix<T> operator*(const Matrix<T>& lhs, const Matrix<T>& rhs)$/;"	f	namespace:quadprogpp
operator *	quadprog_optimized/Array.hh	/^Matrix<T> operator*(const Matrix<T>& lhs, const T& a)$/;"	f	namespace:quadprogpp
operator *	quadprog_optimized/Array.hh	/^Matrix<T> operator*(const T& a, const Matrix<T>& rhs)$/;"	f	namespace:quadprogpp
operator *	quadprog_optimized/Array.hh	/^inline Vector<T> operator*(const T& a, const Vector<T>& rhs)$/;"	f	namespace:quadprogpp
operator *	quadprog_optimized/Array.hh	/^inline Vector<T> operator*(const Vector<T>& lhs, const T& a)$/;"	f	namespace:quadprogpp
operator *	quadprog_optimized/Array.hh	/^inline Vector<T> operator*(const Vector<T>& lhs, const Vector<T>& rhs)$/;"	f	namespace:quadprogpp
operator *=	quadprog_optimized/Array.hh	/^inline Matrix<T>& Matrix<T>::operator*=(const Matrix<T>& rhs)$/;"	f	class:quadprogpp::Matrix
operator *=	quadprog_optimized/Array.hh	/^inline Matrix<T>& Matrix<T>::operator*=(const T& a)$/;"	f	class:quadprogpp::Matrix
operator *=	quadprog_optimized/Array.hh	/^inline Vector<T>& Vector<T>::operator*=(const T& a)$/;"	f	class:quadprogpp::Vector
operator *=	quadprog_optimized/Array.hh	/^inline Vector<T>& Vector<T>::operator*=(const Vector<T>& rhs)$/;"	f	class:quadprogpp::Vector
operator +	quadprog_optimized/Array.hh	/^Matrix<T> operator+(const Matrix<T>& lhs, const Matrix<T>& rhs)$/;"	f	namespace:quadprogpp
operator +	quadprog_optimized/Array.hh	/^Matrix<T> operator+(const Matrix<T>& lhs, const T& a)$/;"	f	namespace:quadprogpp
operator +	quadprog_optimized/Array.hh	/^Matrix<T> operator+(const Matrix<T>& rhs)$/;"	f	namespace:quadprogpp
operator +	quadprog_optimized/Array.hh	/^Matrix<T> operator+(const T& a, const Matrix<T>& rhs)$/;"	f	namespace:quadprogpp
operator +	quadprog_optimized/Array.hh	/^inline Vector<T> operator+(const T& a, const Vector<T>& rhs)$/;"	f	namespace:quadprogpp
operator +	quadprog_optimized/Array.hh	/^inline Vector<T> operator+(const Vector<T>& lhs, const T& a)$/;"	f	namespace:quadprogpp
operator +	quadprog_optimized/Array.hh	/^inline Vector<T> operator+(const Vector<T>& lhs, const Vector<T>& rhs)$/;"	f	namespace:quadprogpp
operator +	quadprog_optimized/Array.hh	/^inline Vector<T> operator+(const Vector<T>& rhs)$/;"	f	namespace:quadprogpp
operator +=	quadprog_optimized/Array.hh	/^inline Matrix<T>& Matrix<T>::operator+=(const Matrix<T>& rhs)$/;"	f	class:quadprogpp::Matrix
operator +=	quadprog_optimized/Array.hh	/^inline Matrix<T>& Matrix<T>::operator+=(const T& a)$/;"	f	class:quadprogpp::Matrix
operator +=	quadprog_optimized/Array.hh	/^inline Vector<T>& Vector<T>::operator+=(const T& a)$/;"	f	class:quadprogpp::Vector
operator +=	quadprog_optimized/Array.hh	/^inline Vector<T>& Vector<T>::operator+=(const Vector<T>& rhs)$/;"	f	class:quadprogpp::Vector
operator -	quadprog_optimized/Array.hh	/^Matrix<T> operator-(const Matrix<T>& lhs, const Matrix<T>& rhs)$/;"	f	namespace:quadprogpp
operator -	quadprog_optimized/Array.hh	/^Matrix<T> operator-(const Matrix<T>& lhs, const T& a)$/;"	f	namespace:quadprogpp
operator -	quadprog_optimized/Array.hh	/^Matrix<T> operator-(const Matrix<T>& rhs)$/;"	f	namespace:quadprogpp
operator -	quadprog_optimized/Array.hh	/^Matrix<T> operator-(const T& a, const Matrix<T>& rhs)$/;"	f	namespace:quadprogpp
operator -	quadprog_optimized/Array.hh	/^inline Vector<T> operator-(const T& a, const Vector<T>& rhs)$/;"	f	namespace:quadprogpp
operator -	quadprog_optimized/Array.hh	/^inline Vector<T> operator-(const Vector<T>& lhs, const T& a)$/;"	f	namespace:quadprogpp
operator -	quadprog_optimized/Array.hh	/^inline Vector<T> operator-(const Vector<T>& lhs, const Vector<T>& rhs)$/;"	f	namespace:quadprogpp
operator -	quadprog_optimized/Array.hh	/^inline Vector<T> operator-(const Vector<T>& rhs)$/;"	f	namespace:quadprogpp
operator -=	quadprog_optimized/Array.hh	/^inline Matrix<T>& Matrix<T>::operator-=(const Matrix<T>& rhs)$/;"	f	class:quadprogpp::Matrix
operator -=	quadprog_optimized/Array.hh	/^inline Matrix<T>& Matrix<T>::operator-=(const T& a)$/;"	f	class:quadprogpp::Matrix
operator -=	quadprog_optimized/Array.hh	/^inline Vector<T>& Vector<T>::operator-=(const T& a)$/;"	f	class:quadprogpp::Vector
operator -=	quadprog_optimized/Array.hh	/^inline Vector<T>& Vector<T>::operator-=(const Vector<T>& rhs)$/;"	f	class:quadprogpp::Vector
operator /	quadprog_optimized/Array.hh	/^Matrix<T> operator\/(const Matrix<T>& lhs, const Matrix<T>& rhs)$/;"	f	namespace:quadprogpp
operator /	quadprog_optimized/Array.hh	/^Matrix<T> operator\/(const Matrix<T>& lhs, const T& a)$/;"	f	namespace:quadprogpp
operator /	quadprog_optimized/Array.hh	/^Matrix<T> operator\/(const T& a, const Matrix<T>& rhs)$/;"	f	namespace:quadprogpp
operator /	quadprog_optimized/Array.hh	/^inline Vector<T> operator\/(const T& a, const Vector<T>& rhs)$/;"	f	namespace:quadprogpp
operator /	quadprog_optimized/Array.hh	/^inline Vector<T> operator\/(const Vector<T>& lhs, const T& a)$/;"	f	namespace:quadprogpp
operator /	quadprog_optimized/Array.hh	/^inline Vector<T> operator\/(const Vector<T>& lhs, const Vector<T>& rhs)$/;"	f	namespace:quadprogpp
operator /=	quadprog_optimized/Array.hh	/^inline Matrix<T>& Matrix<T>::operator\/=(const Matrix<T>& rhs)$/;"	f	class:quadprogpp::Matrix
operator /=	quadprog_optimized/Array.hh	/^inline Matrix<T>& Matrix<T>::operator\/=(const T& a)$/;"	f	class:quadprogpp::Matrix
operator /=	quadprog_optimized/Array.hh	/^inline Vector<T>& Vector<T>::operator\/=(const T& a)$/;"	f	class:quadprogpp::Vector
operator /=	quadprog_optimized/Array.hh	/^inline Vector<T>& Vector<T>::operator\/=(const Vector<T>& rhs)$/;"	f	class:quadprogpp::Vector
operator <	quadprog_optimized/Array.hh	/^inline bool operator<(const Vector<T>& v, const Vector<T>& w)$/;"	f	namespace:quadprogpp
operator <<	quadprog_optimized/Array.hh	/^inline std::ostream& operator<<(std::ostream& os, const Vector<T>& v)$/;"	f	namespace:quadprogpp
operator <<	quadprog_optimized/Array.hh	/^std::ostream& operator<<(std::ostream& os, const Matrix<T>& m)$/;"	f	namespace:quadprogpp
operator <=	quadprog_optimized/Array.hh	/^inline bool operator<=(const Vector<T>& v, const Vector<T>& w)$/;"	f	namespace:quadprogpp
operator =	quadprog_optimized/Array.hh	/^inline Matrix<T>& Matrix<T>::operator=(const Matrix<T> &rhs) $/;"	f	class:quadprogpp::Matrix
operator =	quadprog_optimized/Array.hh	/^inline Matrix<T>& Matrix<T>::operator=(const T& a) \/\/ assign a to every element $/;"	f	class:quadprogpp::Matrix
operator =	quadprog_optimized/Array.hh	/^inline Vector<T> & Vector<T>::operator=(const T& a) \/\/assign a to every element $/;"	f	class:quadprogpp::Vector
operator =	quadprog_optimized/Array.hh	/^inline Vector<T>& Vector<T>::operator=(const Vector<T>& rhs) $/;"	f	class:quadprogpp::Vector
operator ==	quadprog_optimized/Array.hh	/^inline bool operator==(const Matrix<T>& a, const Matrix<T>& b)$/;"	f	namespace:quadprogpp
operator ==	quadprog_optimized/Array.hh	/^inline bool operator==(const Vector<T>& v, const Vector<T>& w)$/;"	f	namespace:quadprogpp
operator >	quadprog_optimized/Array.hh	/^inline bool operator>(const Vector<T>& v, const Vector<T>& w)$/;"	f	namespace:quadprogpp
operator >=	quadprog_optimized/Array.hh	/^inline bool operator>=(const Vector<T>& v, const Vector<T>& w)$/;"	f	namespace:quadprogpp
operator >>	quadprog_optimized/Array.hh	/^std::istream& operator>>(std::istream& is, Matrix<T>& m)$/;"	f	namespace:quadprogpp
operator >>	quadprog_optimized/Array.hh	/^std::istream& operator>>(std::istream& is, Vector<T>& v)$/;"	f	namespace:quadprogpp
operator Vector<T>	quadprog_optimized/Array.hh	/^inline Matrix<T>::operator Vector<T>()$/;"	f	class:quadprogpp::Matrix
operator []	quadprog_optimized/Array.hh	/^  inline T* operator[](const unsigned int& i) { return v[i]; } \/\/ Subscripting: row i$/;"	f	class:quadprogpp::Matrix
operator []	quadprog_optimized/Array.hh	/^  inline const T* operator[](const unsigned int& i) const { return v[i]; }; \/\/ const subsctipting$/;"	f	class:quadprogpp::Matrix
operator []	quadprog_optimized/Array.hh	/^inline T & Vector<T>::operator[](const unsigned int& i) \/\/subscripting $/;"	f	class:quadprogpp::Vector
operator []	quadprog_optimized/Array.hh	/^inline const T& Vector<T>::operator[](const unsigned int& i) const \/\/subscripting $/;"	f	class:quadprogpp::Vector
operator ^	quadprog_optimized/Array.hh	/^Matrix<T> operator^(const Matrix<T>& lhs, const T& a)$/;"	f	namespace:quadprogpp
operator ^	quadprog_optimized/Array.hh	/^inline Vector<T> operator^(const T& a, const Vector<T>& rhs)$/;"	f	namespace:quadprogpp
operator ^	quadprog_optimized/Array.hh	/^inline Vector<T> operator^(const Vector<T>& lhs, const T& a)$/;"	f	namespace:quadprogpp
operator ^	quadprog_optimized/Array.hh	/^inline Vector<T> operator^(const Vector<T>& lhs, const Vector<T>& rhs)$/;"	f	namespace:quadprogpp
operator ^=	quadprog_optimized/Array.hh	/^inline Matrix<T>& Matrix<T>::operator^=(const Matrix<T>& rhs)$/;"	f	class:quadprogpp::Matrix
operator ^=	quadprog_optimized/Array.hh	/^inline Matrix<T>& Matrix<T>::operator^=(const T& a)$/;"	f	class:quadprogpp::Matrix
operator ^=	quadprog_optimized/Array.hh	/^inline Vector<T>& Vector<T>::operator^=(const T& a)$/;"	f	class:quadprogpp::Vector
operator ^=	quadprog_optimized/Array.hh	/^inline Vector<T>& Vector<T>::operator^=(const Vector<T>& rhs)$/;"	f	class:quadprogpp::Vector
partition	quadprog_optimized/Array.hh	/^inline unsigned int partition(Vector<T>& v, unsigned int begin, unsigned int end)$/;"	f	namespace:quadprogpp
pinv	quadprog_optimized/Array.hh	/^Matrix<T> pinv(const Matrix<T>& A)$/;"	f	namespace:quadprogpp
pow	quadprog_optimized/Array.hh	/^inline Vector<T> pow(const Vector<T>& v, double a)$/;"	f	namespace:quadprogpp
prod	quadprog_optimized/Array.hh	/^Vector<T> prod(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
prod	quadprog_optimized/Array.hh	/^inline T prod(const Vector<T>& v)$/;"	f	namespace:quadprogpp
quadprogpp	quadprog_optimized/Array.hh	/^namespace quadprogpp {$/;"	n
quicksort	quadprog_optimized/Array.hh	/^inline void quicksort(Vector<T>& v, unsigned int begin, unsigned int end)$/;"	f	namespace:quadprogpp
r_max	quadprog_optimized/Array.hh	/^Vector<T> r_max(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
r_mean	quadprog_optimized/Array.hh	/^Vector<T> r_mean(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
r_min	quadprog_optimized/Array.hh	/^Vector<T> r_min(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
r_prod	quadprog_optimized/Array.hh	/^Vector<T> r_prod(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
r_rank	quadprog_optimized/Array.hh	/^inline Matrix<double> r_rank(const Matrix<T> m)$/;"	f	namespace:quadprogpp
r_stdev	quadprog_optimized/Array.hh	/^Vector<T> r_stdev(const Matrix<T>& m, bool sample_correction = false)$/;"	f	namespace:quadprogpp
r_sum	quadprog_optimized/Array.hh	/^Vector<T> r_sum(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
r_var	quadprog_optimized/Array.hh	/^Vector<T> r_var(const Matrix<T>& m, bool sample_correction = false)$/;"	f	namespace:quadprogpp
random	quadprog_optimized/Array.hh	/^void random(Matrix<T>& m)$/;"	f	namespace:quadprogpp
rank	quadprog_optimized/Array.hh	/^inline Matrix<double> rank(const Matrix<T> m)$/;"	f	namespace:quadprogpp
rank	quadprog_optimized/Array.hh	/^inline Vector<double> rank(const Vector<T>& v)$/;"	f	namespace:quadprogpp
reset	quadprog_optimized/Array.hh	/^inline void CanonicalBaseVector<T>::reset(unsigned int i)$/;"	f	class:quadprogpp::CanonicalBaseVector
resize	quadprog_optimized/Array.hh	/^inline void Matrix<T>::resize(const T& a, const unsigned int n, const unsigned int m) $/;"	f	class:quadprogpp::Matrix
resize	quadprog_optimized/Array.hh	/^inline void Matrix<T>::resize(const unsigned int n, const unsigned int m) $/;"	f	class:quadprogpp::Matrix
resize	quadprog_optimized/Array.hh	/^void Vector<T>::resize(const T& a, const unsigned int n) $/;"	f	class:quadprogpp::Vector
resize	quadprog_optimized/Array.hh	/^void Vector<T>::resize(const unsigned int n) $/;"	f	class:quadprogpp::Vector
set	quadprog_optimized/Array.hh	/^inline void Matrix<T>::set(const T* a, unsigned int n, unsigned int m)$/;"	f	class:quadprogpp::Matrix
set	quadprog_optimized/Array.hh	/^inline void Matrix<T>::set(const std::set<unsigned int>& r_indexes, const std::set<unsigned int>& c_indexes, const Matrix<T>& a)$/;"	f	class:quadprogpp::Matrix
set	quadprog_optimized/Array.hh	/^inline void Vector<T>::set(const T* a, unsigned int n) $/;"	f	class:quadprogpp::Vector
setColumn	quadprog_optimized/Array.hh	/^inline void Matrix<T>::setColumn(unsigned int j, const Matrix<T>& a)$/;"	f	class:quadprogpp::Matrix
setColumn	quadprog_optimized/Array.hh	/^inline void Matrix<T>::setColumn(unsigned int j, const Vector<T>& a)$/;"	f	class:quadprogpp::Matrix
setColumns	quadprog_optimized/Array.hh	/^inline void Matrix<T>::setColumns(const std::set<unsigned int>& indexes, const Matrix<T>& a)$/;"	f	class:quadprogpp::Matrix
setRow	quadprog_optimized/Array.hh	/^inline void Matrix<T>::setRow(unsigned int i, const Matrix<T>& a)$/;"	f	class:quadprogpp::Matrix
setRow	quadprog_optimized/Array.hh	/^inline void Matrix<T>::setRow(unsigned int i, const Vector<T>& a)$/;"	f	class:quadprogpp::Matrix
setRows	quadprog_optimized/Array.hh	/^inline void Matrix<T>::setRows(const std::set<unsigned int>& indexes, const Matrix<T>& m)$/;"	f	class:quadprogpp::Matrix
sign	quadprog_optimized/Array.hh	/^T sign(const T& v)$/;"	f	namespace:quadprogpp
sign	quadprog_optimized/Array.hh	/^inline Vector<T> sign(const Vector<T>& v)$/;"	f	namespace:quadprogpp
size	quadprog_optimized/Array.hh	/^inline unsigned int Vector<T>::size() const $/;"	f	class:quadprogpp::Vector
solve	quadprog_optimized/Array.hh	2180;"	d
sort	quadprog_optimized/Array.hh	/^inline Vector<T> sort(const Vector<T>& v)$/;"	f	namespace:quadprogpp
stdev	quadprog_optimized/Array.hh	/^Vector<T> stdev(const Matrix<T>& m, bool sample_correction = false)$/;"	f	namespace:quadprogpp
stdev	quadprog_optimized/Array.hh	/^inline T stdev(const Vector<T>& v, bool sample_correction = false)$/;"	f	namespace:quadprogpp
sum	quadprog_optimized/Array.hh	/^Vector<T> sum(const Matrix<T>& m)$/;"	f	namespace:quadprogpp
sum	quadprog_optimized/Array.hh	/^inline T sum(const Vector<T>& v)$/;"	f	namespace:quadprogpp
svd	quadprog_optimized/Array.hh	/^void svd(const Matrix<T>& A, Matrix<T>& U, Vector<T>& W, Matrix<T>& V)$/;"	f	namespace:quadprogpp
t	quadprog_optimized/Array.hh	/^Matrix<T> t(const Matrix<T>& a)$/;"	f	namespace:quadprogpp
v	quadprog_optimized/Array.hh	/^  T **v; \/\/ storage for data$/;"	m	class:quadprogpp::Matrix
v	quadprog_optimized/Array.hh	/^  T* v; \/\/ storage for data$/;"	m	class:quadprogpp::Vector
var	quadprog_optimized/Array.hh	/^Vector<T> var(const Matrix<T>& m, bool sample_correction = false)$/;"	f	namespace:quadprogpp
var	quadprog_optimized/Array.hh	/^inline T var(const Vector<T>& v, bool sample_correction = false)$/;"	f	namespace:quadprogpp
vec_sqrt	quadprog_optimized/Array.hh	/^inline Vector<T> vec_sqrt(const Vector<T>& v)$/;"	f	namespace:quadprogpp
~Matrix	quadprog_optimized/Array.hh	/^Matrix<T>::~Matrix() $/;"	f	class:quadprogpp::Matrix
~Vector	quadprog_optimized/Array.hh	/^Vector<T>::~Vector() $/;"	f	class:quadprogpp::Vector
add_constraint	quadprog_optimized/QuadProg++.cc	/^bool add_constraint(Matrix<double>& R, Matrix<double>& J, Vector<double>& d, int& iq, double& R_norm)$/;"	f	namespace:quadprogpp
backward_elimination	quadprog_optimized/QuadProg++.cc	/^inline void backward_elimination(const Matrix<double>& U, Vector<double>& x, const Vector<double>& y)$/;"	f	namespace:quadprogpp
cholesky_decomposition	quadprog_optimized/QuadProg++.cc	/^void cholesky_decomposition(Matrix<double>& A) $/;"	f	namespace:quadprogpp
cholesky_solve	quadprog_optimized/QuadProg++.cc	/^void cholesky_solve(const Matrix<double>& L, Vector<double>& x, const Vector<double>& b)$/;"	f	namespace:quadprogpp
compute_d	quadprog_optimized/QuadProg++.cc	/^inline void compute_d(Vector<double>& d, const Matrix<double>& J, const Vector<double>& np)$/;"	f	namespace:quadprogpp
delete_constraint	quadprog_optimized/QuadProg++.cc	/^void delete_constraint(Matrix<double>& R, Matrix<double>& J, Vector<int>& A, Vector<double>& u, int n, int p, int& iq, int l)$/;"	f	namespace:quadprogpp
distance	quadprog_optimized/QuadProg++.cc	/^inline double distance(double a, double b)$/;"	f	namespace:quadprogpp
forward_elimination	quadprog_optimized/QuadProg++.cc	/^inline void forward_elimination(const Matrix<double>& L, Vector<double>& y, const Vector<double>& b)$/;"	f	namespace:quadprogpp
print_matrix	quadprog_optimized/QuadProg++.cc	/^void print_matrix(const char* name, const Matrix<double>& A, int n, int m)$/;"	f	namespace:quadprogpp
print_vector	quadprog_optimized/QuadProg++.cc	/^void print_vector(const char* name, const Vector<T>& v, int n)$/;"	f	namespace:quadprogpp
quadprogpp	quadprog_optimized/QuadProg++.cc	/^namespace quadprogpp {$/;"	n	file:
scalar_product	quadprog_optimized/QuadProg++.cc	/^inline double scalar_product(const Vector<double>& x, const Vector<double>& y)$/;"	f	namespace:quadprogpp
solve_quadprog	quadprog_optimized/QuadProg++.cc	/^double solve_quadprog(Matrix<double>& G, Vector<double>& g0, $/;"	f	namespace:quadprogpp
update_r	quadprog_optimized/QuadProg++.cc	/^inline void update_r(const Matrix<double>& R, Vector<double>& r, const Vector<double>& d, int iq)$/;"	f	namespace:quadprogpp
update_z	quadprog_optimized/QuadProg++.cc	/^inline void update_z(Vector<double>& z, const Matrix<double>& J, const Vector<double>& d, int iq)$/;"	f	namespace:quadprogpp
_QUADPROGPP	quadprog_optimized/QuadProg++.hh	63;"	d
quadprogpp	quadprog_optimized/QuadProg++.hh	/^namespace quadprogpp {$/;"	n
